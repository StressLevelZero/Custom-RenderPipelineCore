// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel EncodeHemiOctNormsRGBToRG
#pragma kernel EncodeHemiOctNormsRGBToAG
#pragma kernel EncodeHemiOctNormsAGToAG
#pragma kernel PopulateVarRG
#pragma kernel PopulateVarAG
#pragma kernel AverageBlock
#pragma kernel CalcVariance
#pragma kernel SetSmooth
#pragma kernel RGBtoDXTnm

Texture2D<float4> _Input;
Texture2D<float4> _Input2;
RWTexture2D<float4> _Output;
uint4 _texDims; //_Input width, _Input height, _Output width, _Output height;
uint _blockDim;
uint _mipLevel;
float _roughnessPow;

/*
 * Normal vector to hemi-octahedral coordinates
 * Taken from Packing.hlsl in the render pipeline core
 */
float2 PackNormalHemiOctEncode(float3 n)
{
    float l1norm = dot(abs(n), 1.0);
    float2 res = n.xy * (1.0 / l1norm);
    return float2(res.x + res.y, res.x - res.y);
}

/*
 * Given a RG normal, outputs a tangent normal vector 
 */
float3 UnpackNormalRG(float2 packedNormal)
{
    float3 normal;
    normal.xy = packedNormal.rg * 2.0 - 1.0;
    normal.z = max(1.0e-16, sqrt(1 - saturate(dot(normal.xy,normal.xy))));
    return normal;
}

/*
 * Encode an RGB normal texture to hemi-octahedral coordinates in RG
 */
[numthreads(32u,32u,1u)]
void EncodeHemiOctNormsRGBToRG (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x < _texDims.z && id.y < _texDims.w)
    {
        float4 originalColor = _Output[id.xy];
        float3 normal = UnpackNormalRG(originalColor.rg);
        float2 octCoords = PackNormalHemiOctEncode(normal);
        octCoords = 0.5 * octCoords + 0.5;
        _Output[id.xy] = float4(octCoords, originalColor.ba);
    }
}

/*
 * Encode an RGB normal texture to hemi-octahedral coordinates in AG
 */
[numthreads(32u,32u,1u)]
void EncodeHemiOctNormsRGBToAG (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x < _texDims.z && id.y < _texDims.w)
    {
        float4 originalColor = _Output[id.xy];
        float3 normal = UnpackNormalRG(originalColor.rg);
        float2 octCoords = PackNormalHemiOctEncode(normal);
        octCoords = 0.5 * octCoords + 0.5;
        _Output[id.xy] = float4(1.0f, octCoords.y, originalColor.b, octCoords.x);
    }
}

/*
 * Encode a DXT5nm-style AG normal texture to hemi-octahedral coordinates in AG
 */
[numthreads(32u,32u,1u)]
void EncodeHemiOctNormsAGToAG (uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)_texDims.z && id.y < (uint)_texDims.w)
    {
        float4 originalColor = _Output[id.xy];
        float3 normal = UnpackNormalRG(originalColor.ag);
        float2 octCoords = PackNormalHemiOctEncode(normal);
        octCoords = 0.5 * octCoords + 0.5;
        _Output[id.xy] = float4(1.0f, octCoords.y, originalColor.b, octCoords.x);
    }
}

[numthreads(32u,32u,1u)]
void PopulateVarRG (uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)_texDims.z && id.y < (uint)_texDims.w)
    {
        float4 input = _Input.Load(id);
        _Output[id.xy] = float4(input.r, input.r * input.r, input.g, input.g * input.g);
    }
}

[numthreads(32u,32u,1u)]
void PopulateVarAG (uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)_texDims.z && id.y < (uint)_texDims.w)
    {
        float4 input = _Input.Load(uint3(id.xy,0));
        _Output[id.xy] = float4(input.a, input.a * input.a, input.g, input.g * input.g);
    }
}

[numthreads(32u,32u,1u)]
void AverageBlock (uint3 id : SV_DispatchThreadID)
{
     
    if (id.x < (uint)_texDims.z && id.y < (uint)_texDims.w)
    {
        uint2 blockUV = id.xy * _blockDim;
        float4 total = float4(0,0,0,0);
        for (uint v = 0; v < _blockDim; v++)
        {
            for (uint u = 0; u < _blockDim; u++)
            {
                uint2 uv = blockUV.xy + uint2(u, v);
                uv = min(uv, _texDims.xy - 1);
                total += _Input.Load(uint3(uv, 0));
            }
        }
        total /= (float)(_blockDim * _blockDim);
        _Output[id.xy] = total;
    }
}

[numthreads(32u,32u,1u)]
void CalcVariance(uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)_texDims.x && id.y < (uint)_texDims.y)
    {
        float4 varianceTerms = _Input.Load(uint3(id.xy, 0));
        float2 variance = max(0, varianceTerms.yw - varianceTerms.xz * varianceTerms.xz);
        float avgVariance = 1.0 - sqrt(0.5 * (variance.x + variance.y));
        avgVariance = pow(avgVariance, _roughnessPow);
        float4 originalColor = _Input2.Load(uint3(id.xy, _mipLevel));
        _Output[id.xy] = float4(originalColor.r, originalColor.g, avgVariance, originalColor.a);
    }
}

[numthreads(32u,32u,1u)]
void SetSmooth(uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)_texDims.z && id.y < (uint)_texDims.w)
    {
        float4 color = _Output[id.xy];
        _Output[id.xy] = float4(color.r, color.g, 1.0, color.a);
    }
}

[numthreads(32u,32u,1u)]
void RGBtoDXTnm(uint3 id : SV_DispatchThreadID)
{
    if (id.x < (uint)_texDims.z && id.y < (uint)_texDims.w)
    {
        float4 color = _Output[id.xy];
        _Output[id.xy] = float4(1.0, color.g, color.b, color.r);
    }
}